<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DigiTreeLabs â€” ScanSeq (Original-style)</title>
  <script src="https://unpkg.com/p5@1.9.3/lib/p5.min.js"></script>
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <style>
    :root{ --bg:#0b0f14; --panel:#121821; --muted:#92a0b5; --fg:#e6eefc; --accent:#5eead4; }
    *{box-sizing:border-box}
    body{ margin:0; background:#0b0f14; color:var(--fg); font:500 15px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .wrap{ max-width:1200px; margin:24px auto; padding:0 16px; }
    .panel{ background:#0f1520; border-radius:16px; padding:16px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }
    .brand{ display:flex; align-items:baseline; gap:10px; margin:0 0 6px }
    .brand .tag{ font-size:12px; color:#94a3b8; border:1px solid #243045; padding:2px 8px; border-radius:999px }
    .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin:10px 0 }
    .controls{ display:grid; grid-template-columns: repeat(2, minmax(220px,1fr)); gap:10px }
    .controls .row{ grid-template-columns: 1fr 1fr }
    button{ background:linear-gradient(135deg, #7c3aed, #5eead4); color:#0b0f14; border:none; padding:10px 12px; font-weight:800; border-radius:12px; cursor:pointer }
    .muted{ color:var(--muted) }
    #diag{ white-space:pre-wrap; background:#0c1220; border:1px solid #22304a; color:#d1e7ff; padding:10px; border-radius:10px; min-height:60px; margin-top:8px }
    #p5-holder canvas{ width:100%; height:auto; display:block; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.35) }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="brand">
        <h2 style="margin:0">DigiTreeLabs â€” Scan Sequencer (camera â†’ notes)</h2>
        <span class="tag">Original feel + right-side GIF</span>
      </div>
      <p class="muted">Left panel is the camera <i>sensing</i> area. Right panel shows stripes & dots. A dot spawns when motion is detected at the boundary, moves right, and <i>plays</i> when it crosses the wavy line. A dancing GIF is shown on the right for a beautiful overlay.</p>

      <div class="controls">
        <div class="row"><label>Start audio</label><button id="btnStart">Start</button></div>
        <div class="row"><label>Speed</label><input id="speed" type="range" min="1" max="20" step="1" value="8"></div>
        <div class="row"><label>Motion threshold</label><input id="mthr" type="range" min="5" max="100" step="1" value="40"></div>
        <div class="row"><label>Mirror webcam</label><input id="mirror" type="checkbox" checked></div>
        <div class="row"><label>Master volume (dB)</label><input id="vol" type="range" min="-36" max="0" step="1" value="-12"></div>
        <div class="row"><label>BPM</label><input id="bpm" type="range" min="60" max="160" step="1" value="104"></div>
        <div class="row"><label>Groove (predefined notes)</label><input id="groove" type="checkbox"></div>
        <div class="row"><label>Pattern</label>
          <select id="grooveSel">
            <option value="off" selected>Off (camera only)</option>
            <option value="arp">Arp Up</option>
            <option value="backbeat">Backbeat Chords</option>
            <option value="pentajam">Pentatonic Jam</option>
          </select>
        </div>
        <div class="row"><label>Snapshot</label><button id="btnSnap">Save PNG</button></div>
      </div>

      <div id="p5-holder"></div>
      <div id="diag"></div>
    </div>
  </div>

<script>
(() => {
  const DEFAULT_GIF_URL = 'https://c.tenor.com/Ynm40n9fwNMAAAAd/tenor.gif';

  const el = id => document.getElementById(id);
  const println = (m)=>{ const out=el('diag'); out.textContent += (out.textContent?'\n':'') + m; };
  const btnStart = el('btnStart');
  const btnSnap  = el('btnSnap');
  const speed    = el('speed');
  const mthr     = el('mthr');
  const mirror   = el('mirror');
  const volSlider = el('vol');
  const bpmSlider = el('bpm');
  const grooveChk = el('groove');
  const grooveSel = el('grooveSel');

  // ===== Tone.js (pluckier voice, closer to original) =====
  let started=false, polySynth, delay, reverb, vol, seq;
  function buildSynth(){
    if(polySynth) polySynth.dispose(); if(delay) delay.dispose(); if(reverb) reverb.dispose(); if(vol) vol.dispose(); if(seq) {seq.dispose(); seq=null;}
    reverb = new Tone.JCReverb(0.2);
    delay  = new Tone.FeedbackDelay("16n", 0.4);
    polySynth = new Tone.PolySynth(Tone.Synth, { oscillator:{ partials:[0,2,3,4] } });
    vol = new Tone.Volume(parseInt(volSlider.value,10));
    polySynth.chain(vol, delay, reverb, Tone.Destination);

    Tone.Transport.bpm.value = parseInt(bpmSlider.value,10);

    // 16-step sequence for predefined grooves
    seq = new Tone.Sequence((time, step)=>{
      if(!grooveChk.checked) return;
      playGrooveStep(step, time);
    }, [...Array(16).keys()], '16n');
    seq.start(0);
  }
  async function startAudio(){
    if(started) return; await Tone.start(); if(Tone.getContext().state!=='running') await Tone.getContext().resume(); buildSynth(); started=true; btnStart.textContent='Running âœ“'; btnStart.disabled=true; println('ðŸŽ§ Audio started'); }
  btnStart.addEventListener('click', startAudio);

  // react to slider changes
  volSlider.addEventListener('input', ()=>{ if(vol) vol.volume.value = parseInt(volSlider.value,10); });
  bpmSlider.addEventListener('input', ()=>{ Tone.Transport.bpm.value = parseInt(bpmSlider.value,10); });

  // predefined groove helper (uses globals created inside p5 sketch; keep same behavior)
  function playGrooveStep(step, time){
    const pat = grooveSel.value;
    const lanes = [];
    if(pat === 'arp'){ lanes.push(step % 8 + 6); }
    else if(pat === 'backbeat'){ if(step%4===0) lanes.push(4,9,14); }
    else if(pat === 'pentajam'){
      const map=[6,8,11,13,15,13,11,8]; lanes.push(map[step%map.length]);
    }
    // fire lanes
    for(const i of lanes){
      // visual dot (vars come from p5 sketch scope via global window refs set below)
      if(window._scan && window.scan.laneKick) window._scan.laneKick(i);
      // sound
      if(started && polySynth && window._scan && window._scan.noteForLane){
        const note = window.__scan.noteForLane(i);
        polySynth.triggerAttackRelease(note, '16n', time, 1.0);
      }
    }
  }

  // ===== p5 sketch (original-like pipeline + RIGHT GIF overlay) =====
  const sketch = (p) => {
    const lineNum = 20;                 // number of lanes
    let capture, gfx;                    // camera + offscreen
    let buff;                            // 80px sensing strip
    const W=960, H=540;                  // main canvas
    let cameraScreenRatio = H/240;       // scale factor from 240px camera height
    let startPostion = 80 * cameraScreenRatio; // left panel width in canvas px

    // lane state
    let linesColor=[], linesXPos=[], linesMovSpeed=[], linesTrigger=[], linesToneTrigger=[], linesOldSum=[];
    let waveMoving=[], waveMovingFactor=[], waveMovingSpeed=[], waveMovingDec=[];

    // notes (top -> high, bottom -> low)
    const noteListWhole = [
      "C3","E3","D3","G#4","F#4","C4","A#4","D4","F#4","E4",
      "A#4","G#4","D5","C5","F#5","E5","A#5","G#5","C6","D6"
    ];

    // RIGHT-SIDE GIF overlay (preloaded)
    let rightGif = null, rightGifReady = false;

    p.preload = () => {
      rightGif = p.loadImage(DEFAULT_GIF_URL, () => { rightGifReady = true; }, () => { rightGifReady = false; });
    };

    p.setup = () => {
      const c=p.createCanvas(W,H); c.parent('p5-holder'); p.pixelDensity(1);
      capture = p.createCapture({ video:true, audio:false });
      capture.size(320,240); capture.hide();
      gfx = p.createGraphics(320,240);
      buff = p.createImage(80,240);

      for(let i=0;i<lineNum;i++){
        linesXPos[i]=startPostion; linesMovSpeed[i]=0.0; linesTrigger[i]=false; linesToneTrigger[i]=false; linesOldSum[i]=0.0;
        waveMoving[i]=false; waveMovingFactor[i]=0.0; waveMovingSpeed[i]=0.0; waveMovingDec[i]=0.0;
        linesColor[i]=[200,200,200,255];
      }
      println('ðŸ“· Camera ready. Right panel shows stripes + dancing GIF.');
      // expose a tiny API for the groove helper
      window.__scan = {
        laneKick: (i)=>{
          if(i<0||i>=lineNum) return;
          linesXPos[i]=startPostion; linesMovSpeed[i]=5 + parseInt(speed.value,10)*0.8; linesTrigger[i]=true; linesToneTrigger[i]=false; waveMoving[i]=true;
        },
        noteForLane: (i)=> noteListWhole[19 - i]
      };
    };

    // copy rightmost 80px of capture into buff (mirrored so boundary matches)
    function buffImageUpdate(){
      gfx.image(capture, 0, 0, 320, 240);
      gfx.loadPixels(); buff.loadPixels();
      for(let y=0;y<240;y++){
        for(let x=0;x<80;x++){
          const srcX = 319 - x; // right edge of camera
          const idx = (y*320 + srcX)*4;
          buff.pixels[(y*80 + x)*4 + 0] = gfx.pixels[idx+0];
          buff.pixels[(y*80 + x)*4 + 1] = gfx.pixels[idx+1];
          buff.pixels[(y*80 + x)*4 + 2] = gfx.pixels[idx+2];
          buff.pixels[(y*80 + x)*4 + 3] = 255;
        }
      }
      buff.updatePixels();
    }

    // update lane color from capture (one sample per lane)
    function lineColorCapture(){
      gfx.loadPixels();
      for(let i=0;i<lineNum;i++){
        const py = Math.floor((i+0.5)*240/lineNum);
        const px = 320 - 80; // just inside the boundary
        const idx = (py*320 + px)*4;
        linesColor[i] = [ gfx.pixels[idx+0], gfx.pixels[idx+1], gfx.pixels[idx+2], 255 ];
      }
    }

    // draw colored horizontal paths (right panel)
    function pathLineDraw(){
      p.push();
      for(let i=0;i<lineNum;i++){
        p.stroke(linesColor[i][0],linesColor[i][1],linesColor[i][2], 220);
        p.strokeWeight((H/lineNum)*0.5);
        const y = (i+0.5)*H/lineNum;
        p.line(startPostion, y, W, y);
      }
      p.pop();
    }

    function ellipseMoving(){
      p.push(); p.noStroke();
      for(let i=0;i<lineNum;i++){
        linesXPos[i] += linesMovSpeed[i];
        const inv = [255-linesColor[i][0], 255-linesColor[i][1], 255-linesColor[i][2]];
        p.fill(inv[0],inv[1],inv[2]);
        p.circle(linesXPos[i], (i+0.5)*H/lineNum, 10);
      }
      p.pop();
    }

    function waveLineDraw(){
      p.push();
      p.stroke(255,180); p.strokeWeight(2); p.noFill();
      p.beginShape();
      p.curveVertex((W+startPostion)*0.5, 0);
      p.curveVertex((W+startPostion)*0.5, 0);
      for(let i=0;i<lineNum;i++){
        if(waveMoving[i]){ waveMovingSpeed[i]=0.7; waveMoving[i]=false; waveMovingFactor[i]=0.0; waveMovingDec[i]=1.0; }
        waveMovingFactor[i]+=waveMovingSpeed[i]; waveMovingDec[i]*=0.96;
        const wiggle = Math.sin(waveMovingFactor[i]) * 0.5 * waveMovingDec[i] * 30.0;
        p.curveVertex((W+startPostion)*0.5 + wiggle, (i+0.5)*H/lineNum);
      }
      p.curveVertex((W+startPostion)*0.5, H);
      p.curveVertex((W+startPostion)*0.5, H);
      p.endShape();
      p.pop();
    }

    // motion â†’ trigger state + tone decision
    function trigger(){
      const diffThr = parseInt(mthr.value,10);
      for(let i=0;i<lineNum;i++){
        const avg = (linesColor[i][0] + linesColor[i][1] + linesColor[i][2]) / 3.0;
        const diff = Math.abs(avg - linesOldSum[i]);
        if(diff > diffThr){
          linesToneTrigger[i] = false;   // re-arm tone
          linesTrigger[i] = true;        // start a dot from boundary
        }
        linesOldSum[i] = avg;

        // play once when crossing center
        if(linesXPos[i] > (W + startPostion) * 0.5 && linesToneTrigger[i] === false){
          waveMoving[i] = true;
          linesToneTrigger[i] = true;
          if(started && polySynth){
            try{ polySynth.triggerAttackRelease(noteListWhole[19 - i], "32t", undefined, 0.9); }catch(e){ println('tone error: '+e); }
          }
        }

        // reset dot when off the right side
        if(linesXPos[i] > W){
          linesXPos[i] = startPostion; linesTrigger[i] = false; linesToneTrigger[i] = true; linesMovSpeed[i]=0.0;
        }

        // give motion/inertia when triggered; otherwise keep at boundary
        if(linesTrigger[i]){
          const spd = parseInt(speed.value,10);
          linesMovSpeed[i] = 5 + spd*0.8; // tuneable
        } else {
          linesXPos[i] = startPostion; linesMovSpeed[i] = 0.0;
        }
      }
    }

    // helper: draw GIF centered in the right panel with preserved aspect ratio
    function drawRightGif(opacity = 0.7){
      if(!rightGifReady) return;
      const rightX = startPostion, rightW = W - startPostion, rightH = H;
      const wr = rightW / rightGif.width;
      const hr = rightH / rightGif.height;
      const s = Math.min(wr, hr); // contain
      const gw = rightGif.width * s;
      const gh = rightGif.height * s;
      const gx = rightX + (rightW - gw)/2;
      const gy = (rightH - gh)/2;
      p.push();
      p.tint(255, Math.floor(opacity * 255));
      p.image(rightGif, gx, gy, gw, gh);
      p.pop();
    }

    p.draw = () => {
      p.background(0);

      // webcam â†’ buff (80px) and lane colors
      buffImageUpdate();
      lineColorCapture();
      trigger();

      // left: show sensing strip scaled up; mirror if requested
      p.push();
      if(mirror.checked){ p.translate(startPostion,0); p.scale(-1,1); }
      p.image(buff, 0, 0, startPostion, 240*cameraScreenRatio);
      p.pop();

      // RIGHT GIF behind content
      drawRightGif(0.7);

      // right visuals & motion
      pathLineDraw();
      ellipseMoving();
      waveLineDraw();

      // boundary markers
      p.noStroke(); p.fill(220,220,220,180);
      for(let i=0;i<lineNum;i++){ p.circle(startPostion-6, (i+0.5)*H/lineNum, 6); }

      // HUD (fixed template string)
      p.fill(255,150); p.textSize(12);
      p.text(thr:${mthr.value} spd:${speed.value}, 10, 16);
    };

    btnSnap.addEventListener('click', ()=>{ p.saveCanvas('scanseq_snapshot', 'png'); });
  };

  window.onload = () => new p5(sketch);
})();
</script>
</body>
</html>
